---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```

# splice2neo

<!-- badges: start -->
[![R-CMD-check](https://github.com/TRON-Bioinformatics/splice2neo/workflows/R-CMD-check/badge.svg)](https://github.com/TRON-Bioinformatics/splice2neo/actions)
[![Codecov test coverage](https://codecov.io/gh/TRON-Bioinformatics/splice2neo/branch/master/graph/badge.svg)](https://codecov.io/gh/TRON-Bioinformatics/splice2neo?branch=master)
`r badger::badge_devel("TRON-Bioinformatics/splice2neo", "blue")`
`r badger::badge_lifecycle("experimental", "blue")`
`r badger::badge_last_commit("TRON-Bioinformatics/splice2neo")`
<!-- badges: end -->

This package provides functions for the analysis of alternative splicing
junctions and their association with somatic mutations. It integrates the output
of several tools which predict splicing effects from mutations or which detect
expressed splice junctions from RNA-seq data into a standardized splice junction
format based on genomic coordinates. Detected splice junctions can be filtered
against canonical ones and annotated with affected transcript sequences, CDS,
and resulting peptide sequences. The resulting tumor-specific splice junctions
can encode neoantigens.
 
Website: https://tron-bioinformatics.github.io/splice2neo/
 
## Installation

This R package is not yet on [CRAN](https://CRAN.R-project.org) or
[Bioconductor](https://www.bioconductor.org/). Therefore, you need to install it
from this repository. 

```{r, eval = FALSE}
## install.packages("remotes")
remotes::install_github("TRON-Bioinformatics/splice2neo")
```

## Example

This is a basic example of how to use some functions.

```{r}
library(splice2neo)

# load human genome reference sequence
requireNamespace("BSgenome.Hsapiens.UCSC.hg19", quietly = TRUE)
bsg <- BSgenome.Hsapiens.UCSC.hg19::BSgenome.Hsapiens.UCSC.hg19

```

### Example data

We start with some example splice junctions provided with the package.
 
```{r}
junc_df <- dplyr::tibble(
  junc_id = toy_junc_id[c(1, 6, 10)]
)

junc_df
```

### Add transcripts 

Next, we find the transcripts which are affected by the splice junctions.

```{r}
junc_df <- junc_df %>% 
  add_tx(toy_transcripts)

junc_df
```

### Modify transcripts with junctions

We modify the canonical transcripts by introducing the splice junctions. Then we
add the transcript sequence in a fixed-sized window around the junction
positions, the context sequence.


```{r}
toy_junc_df


junc_df <- toy_junc_df %>% 
  add_context_seq(transcripts = toy_transcripts, size = 400, bsg = bsg)


junc_df

```

### Annotate peptide sequence

Finally, we use the splice junctions to modify the coding sequences (CDS) of the
reference transcripts. The resulting CDS sequences are translated into protein
sequence and further annotated with the peptide around the junction, the
relative position of the splice junction in the peptide, and the location of the
junction in an open reading frame (ORF).

```{r}

junc_df <- junc_df %>% 
  add_peptide(cds=toy_cds, size = 30, bsg = bsg)

junc_df %>% 
  dplyr::select(junc_id, junc_in_orf, peptide_context, peptide_context_junc_pos)

```


## Dummy example

In the following a dummy example workflow how to integrate predict splicing effects from mutations or which detect
expressed splice junctions from RNA-seq data to predict potential neoantigen candidates with splice2neo. 
A test case will be added later

```{r, eval = FALSE, echo = TRUE}
library(splice2neo)
library(tidyverse)
# load genome of choice
library(BSgenome.Hsapiens.UCSC.hg19)
library(AnnotationDbi)

# this is an customized example of a transcript database
# the user can choose the best suited database for their use case
# please find below instruction how to create the database from a gtf file
gtf_url <- "ftp://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_34/GRCh37_mapping/gencode.v34lift37.annotation.gtf.gz"
# parse GTF file as txdb object
txdb <- GenomicFeatures::makeTxDbFromGFF(gtf_url)

transcripts <-
  GenomicFeatures::exonsBy(txdb, by = c("tx"), use.names = TRUE)
transcripts_gr <- GenomicFeatures::transcripts(txdb)
# Build a GRangesList with cds composed of individual exon ranges
cds <- GenomicFeatures::cdsBy(txdb, by = c("tx"), use.name = TRUE)

# canonical junctions
# the user can choose the best suited data sets for canonical junctions
# the object `canonical junction` should be a vector of canonical junctions in the junction format
canonical_juncs <-
  c("chr1:33361245-33361511:-",
    "chr1:32849649-32852380:-",
    "chrom:start-end:strand")
# OPTIONAL: if canonical junctions are available as a bed file, the user can transform the bed file into the juntion format:
# for bed files defined by exon-exon boundaries:
canonical_juncs <- bed_to_junc(bed_file = "/path/to/canonical/file.bed", type = "exon-exon")
# for bed files defined by introns:
canonical_juncs <- bed_to_junc(bed_file = "/path/to/canonical/file.bed", type = "intron")


# import RNA data
dat_leafcutter <-
  leafcutter_transform(path = "/your/path/to/leafcutter/results")
# supported events: exon_skip, intron_retention, alt_3prime, alt_5prime, mutex_exons
dat_spladder <-
  spladder_transform(path = "/your/path/to/spladder/results")
dat_rna <-
  generate_combined_dataset(spladder_juncs = dat_spladder, leafcutter_juncs = dat_spladder)

# import & transform SpliceAi results
dat_spliceai <-
  parse_spliceai(vcf_file = "path/to/spliceai/file.vcf")
dat_splicai_formatted <- format_spliceai(dat_spliceai)
dat_spliceai_annotated <-
  annotate_spliceai_junction(var_df = dat_splicai_formatted,
                             transcripts = transcripts,
                             transcripts_gr = transcripts_gr)

# import & transform MMSplice results
dat_mmsplice <- parse_mmsplice(infile = "path/to/mmsplice/file.csv")
dat_mmsplice_annotated  <-
  annotate_mmsplice(mmsplice_df = dat_mmsplice, transcripts = transcripts)

# mutation-based junctions
dat_mut <-
  combine_mut_junc(spliceai_juncs = dat_spliceai_annotated, mmsplice_juncs = dat_mmsplice_annotated)

# add information if junction is canonical and if found to be expressed by SplAdder or LeafCutter
dat_mut <- dat_mut %>%
  mutate(is_canonical = is_canonical(junc_id, ref_junc = canonical_juncs, exons_gr = transcripts)) %>%
  mutate(is_in_rnaseq = is_in_rnaseq(junc_id, rna_juncs = dat_rna$junc_id))

# remove canonical junctions for further downstream analysis
dat_for_requantification <- dat_mut %>%
  filter(!is_canonical)

# add context sequences
# a list of GRanges with the transcript needs to be added at the moment
# this will be done within add_context_seq in a future version
dat_for_requantification_cts <- dat_for_requantification %>%
  add_context_seq(size = 400, bsg = BSgenome.Hsapiens.UCSC.hg19, transcripts = transcripts)


# transform to easyquant-format
dat_easyquant <- dat_for_requantification_cts %>%
  transform_for_requant()
write_delim(dat_easyquant, "path/to/easyquant/input/file.txt", delim = "\t")
# DO RE-QUANTIFICATION WITH EASYQUANT
# https://github.com/TRON-Bioinformatics/easyquant


# add peptide sequence
dat_for_requantification_cts_peptide <-
  dat_for_requantification_cts  %>%
  add_peptide(size = 30, bsg = BSgenome.Hsapiens.UCSC.hg19, cds = cds)

# merge EasyQuant results with data
dat_cts_peptide_requantification <-
  map_requant(path_to_easyquant_folder = "/path/to/easyquant/output_folder",
              junc_tib = dat_for_requantification_cts_peptide)


# EasyQuant results can be imported without direct merging with data
dat_requant <-
  read_requant(path_folder = "/path/to/easyquant/output_folder")
```



## Transcript database

To transform mutations into junction format, a database of transcripts is required. This database can be created as described below:  

```{r, eval=F, echo=T}
# use gtf file of choice and transform into transcript database
gtf_url <- "ftp://ftp.ebi.ac.uk/pub/databases/gencode/Gencode_human/release_34/GRCh37_mapping/gencode.v34lift37.annotation.gtf.gz"

# parse GTF file as txdb object
txdb <- GenomicFeatures::makeTxDbFromGFF(gtf_url)
saveDb(txdb, file = "/path/to/transripts/txdb.sqlite")

# load 
txdb <- loadDb("/path/to/transripts/txdb.sqlite")

```

